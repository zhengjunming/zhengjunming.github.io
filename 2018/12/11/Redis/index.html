
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Redis底层数据结构 | 小铭</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="ming">
    

    
    <meta name="description" content="简单动态字符串SDS的定义 1234567891011struct sdshdr &amp;#123;    // 记录buf数组中已使用字节的数量    // 等于SDS所保存字符串的长度    int len;        // 记录buf数组中未使用字节的数量    int free;        // 字节数组，用于保存字符串    char buf[];&amp;#125;;  杜绝缓冲区溢出 空间">
<meta name="keywords" content="redis">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis底层数据结构">
<meta property="og:url" content="http://minsming.com/2018/12/11/Redis/index.html">
<meta property="og:site_name" content="小铭">
<meta property="og:description" content="简单动态字符串SDS的定义 1234567891011struct sdshdr &amp;#123;    // 记录buf数组中已使用字节的数量    // 等于SDS所保存字符串的长度    int len;        // 记录buf数组中未使用字节的数量    int free;        // 字节数组，用于保存字符串    char buf[];&amp;#125;;  杜绝缓冲区溢出 空间">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://minsming.com/img/空哈希表.png">
<meta property="og:image" content="http://minsming.com/img/压缩列表组成.png">
<meta property="og:image" content="http://minsming.com/img/压缩列表节点.png">
<meta property="og:updated_time" content="2018-12-11T10:53:52.866Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis底层数据结构">
<meta name="twitter:description" content="简单动态字符串SDS的定义 1234567891011struct sdshdr &amp;#123;    // 记录buf数组中已使用字节的数量    // 等于SDS所保存字符串的长度    int len;        // 记录buf数组中未使用字节的数量    int free;        // 字节数组，用于保存字符串    char buf[];&amp;#125;;  杜绝缓冲区溢出 空间">
<meta name="twitter:image" content="http://minsming.com/img/空哈希表.png">

    
    <link rel="alternative" href="/atom.xml" title="小铭" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/apple.jpeg">
    
    
    <link rel="apple-touch-icon" href="/img/apple.jpeg">
    <link rel="apple-touch-icon-precomposed" href="/img/apple.jpeg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/apple.jpeg" alt="小铭" title="小铭"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="小铭">小铭</a></h1>
				<h2 class="blog-motto">春生，夏糜，秋去，冬烬，春又来。</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于我</a></li>
					
					<li>
 					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/12/11/Redis/" title="Redis底层数据结构" itemprop="url">Redis底层数据结构</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ming" target="_blank" itemprop="author">ming</a>
		
  <p class="article-time">
    <time datetime="2018-12-11T10:53:52.866Z" itemprop="datePublished"> 发表于 2018-12-11</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#简单动态字符串"><span class="toc-number">1.</span> <span class="toc-text">简单动态字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#链表"><span class="toc-number">2.</span> <span class="toc-text">链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字典"><span class="toc-number">3.</span> <span class="toc-text">字典</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#哈希表"><span class="toc-number">3.1.</span> <span class="toc-text">哈希表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#哈希表节点"><span class="toc-number">3.2.</span> <span class="toc-text">哈希表节点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字典-1"><span class="toc-number">4.</span> <span class="toc-text">字典</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rehash过程"><span class="toc-number">4.1.</span> <span class="toc-text">rehash过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#哈希表的扩展与收缩"><span class="toc-number">4.2.</span> <span class="toc-text">哈希表的扩展与收缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#渐进式rehash"><span class="toc-number">4.3.</span> <span class="toc-text">渐进式rehash</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#跳跃表"><span class="toc-number">5.</span> <span class="toc-text">跳跃表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#跳跃表节点"><span class="toc-number">5.1.</span> <span class="toc-text">跳跃表节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结构"><span class="toc-number">5.2.</span> <span class="toc-text">结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#整数集合"><span class="toc-number">6.</span> <span class="toc-text">整数集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#升级"><span class="toc-number">6.1.</span> <span class="toc-text">升级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#压缩列表"><span class="toc-number">7.</span> <span class="toc-text">压缩列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#组成"><span class="toc-number">7.1.</span> <span class="toc-text">组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#压缩列表节点构成"><span class="toc-number">7.2.</span> <span class="toc-text">压缩列表节点构成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#连锁更新"><span class="toc-number">7.3.</span> <span class="toc-text">连锁更新</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象"><span class="toc-number">8.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类型与编码"><span class="toc-number">8.1.</span> <span class="toc-text">类型与编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串对象"><span class="toc-number">8.2.</span> <span class="toc-text">字符串对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#列表对象"><span class="toc-number">8.3.</span> <span class="toc-text">列表对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#哈希对象"><span class="toc-number">8.4.</span> <span class="toc-text">哈希对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集合对象"><span class="toc-number">8.5.</span> <span class="toc-text">集合对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有序集合对象"><span class="toc-number">8.6.</span> <span class="toc-text">有序集合对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型检查"><span class="toc-number">8.7.</span> <span class="toc-text">类型检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多态命令的实现"><span class="toc-number">8.8.</span> <span class="toc-text">多态命令的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存回收"><span class="toc-number">8.9.</span> <span class="toc-text">内存回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象共享"><span class="toc-number">8.10.</span> <span class="toc-text">对象共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象的空转时长"><span class="toc-number">8.11.</span> <span class="toc-text">对象的空转时长</span></a></li></ol></li></ol>
		
		</div>
		
		<h2 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h2><p><strong>SDS的定义</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录buf数组中已使用字节的数量</span></span><br><span class="line">    <span class="comment">// 等于SDS所保存字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>杜绝缓冲区溢出</li>
<li>空间分配策略<ul>
<li>空间预分配（还有一个额外的一字节用于保存空字符）<ul>
<li>对SDS修改之后，SDS的长度将小于1MB，那么程序分配和len属性同样大小的未使用空间，这是SDS len属性的值将和free属性的值相同。</li>
<li>对SDS修改之后，SDS的长度将大于1MB，那么程序分配1MB的未使用空间</li>
</ul>
</li>
<li>惰性空间释放<ul>
<li>当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短多出来的字节，而是使用free属性将这些字节的数量记录下来</li>
</ul>
</li>
</ul>
</li>
<li>二进制安全：SDS使用len属性的值而不是空字符来判断字符串是否结束</li>
</ol>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>节点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">	<span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点值</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure>
<p>链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">  	<span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">&#125;<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ul>
<li>双端</li>
<li>无环</li>
<li>有头指针和尾指针</li>
<li>长度计数器len</li>
<li>多态</li>
</ul>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>
<p><img src="http://minsming.com/img/空哈希表.png" alt=""></p>
<h3 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表（链地址法）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>
<h2 id="字典-1"><a href="#字典-1" class="headerlink" title="字典"></a>字典</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    <span class="comment">// 一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="comment">// 计算哈希值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制值的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对比键的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁值的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure>
<h3 id="rehash过程"><a href="#rehash过程" class="headerlink" title="rehash过程"></a>rehash过程</h3><ol>
<li>为字典的ht[1]哈希表分配空间<ul>
<li>扩展操作：ht[1]的大小为第一个大于等于$ht[0].used * 2$的$2^n$</li>
<li>收缩操作：ht[1]的大小为第一个大于等于$ht[0].used$的$2^n$</li>
</ul>
</li>
<li>将保存在ht[0]中的所有键值对rehash到ht[1]上面</li>
<li>释放ht[0]，将ht[1]设为ht[0]，并在ht[1]新建一个空白哈希表</li>
</ol>
<h3 id="哈希表的扩展与收缩"><a href="#哈希表的扩展与收缩" class="headerlink" title="哈希表的扩展与收缩"></a>哈希表的扩展与收缩</h3><ol>
<li>服务器目前没有在执行<code>BGSAVE</code>命令或者<code>BGREWRITEAOF</code>命令，并且哈希表的负载因子大于等于1</li>
<li>服务器目前正在执行<code>BGSAVE</code>命令或者<code>BGREWRITEAOF</code>命令，并且哈希表的负载因子大于等于5</li>
</ol>
<p>负载因子计算：load_factor = h[0].used / ht[0].size</p>
<h3 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h3><blockquote>
<p>  分多次rehash</p>
</blockquote>
<ol>
<li>为ht[1]分配空间，字典拥有两个哈希表</li>
<li>字典维持一个索引计数器变量<code>rehashidx</code>，设置为0，表示rehash工作开始</li>
<li>rehash进行区间，每次对字典执行添加、删除、查找或者更新操作，会把ht[0]哈希表在<code>rehashidx</code>索引上的键值对rehash到ht[1]，索引值加一</li>
<li>最后结束时，<code>rehashidx</code>为-1</li>
</ol>
<h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><h3 id="跳跃表节点"><a href="#跳跃表节点" class="headerlink" title="跳跃表节点"></a>跳跃表节点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>
<ul>
<li>层（level）：节点中用 <code>L1</code> 、 <code>L2</code> 、 <code>L3</code> 等字样标记节点的各个层， <code>L1</code> 代表第一层， <code>L2</code> 代表第二层，以此类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。</li>
<li>后退（backward）指针：节点中用 <code>BW</code> 字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li>
<li>分值（score）：各个节点中的 <code>1.0</code> 、 <code>2.0</code> 和 <code>3.0</code> 是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。</li>
<li>成员对象（obj）：各个节点中的 <code>o1</code> 、 <code>o2</code> 和 <code>o3</code> 是节点所保存的成员对象。</li>
</ul>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点和表尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表中节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>header</code> ：指向跳跃表的表头节点。</li>
<li><code>tail</code> ：指向跳跃表的表尾节点。</li>
<li><code>level</code> ：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。</li>
<li><code>length</code> ：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。</li>
</ul>
<h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><blockquote>
<p>  整数集合是集合键的底层实现之一，当一个集合只包含整数值元素，并且元素数量不多时，Redis就会使用郑书记和作为集合键的底层实现。</p>
</blockquote>
<p>整数集合（intset）是 Redis 用于保存整数值的集合抽象数据结构， 它可以保存类型为 <code>int16_t</code> 、 <code>int32_t</code> 或者 <code>int64_t</code> 的整数值， 并且保证集合中<strong>不会出现重复元素</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="comment">// INTSET_ENC_INT16（最小值-32768，最大值32767）</span></span><br><span class="line">    <span class="comment">// INTSET_ENC_INT32（最小值-2147483648，最大值2147483647）</span></span><br><span class="line">    <span class="comment">// INTSET_ENC_INT64（最小值-9223372036854775808，最大值9223372036854775807）</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集合包含的元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存元素的数组，从小到大排列</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>
<h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><blockquote>
<p>  每当我们要将一个新元素添加到整数集合里面， 并0且新元素的类型比整数集合现有所有元素的类型都要长时， 整数集合需要先进行<strong>升级（upgrade）</strong>， 然后才能将新元素添加到整数集合里面。</p>
</blockquote>
<ol>
<li>根据新元素的类型， 扩展整数集合底层数组的空间大小， 并为新元素分配空间。</li>
<li>将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。</li>
<li>将新元素添加到底层数组里面。</li>
</ol>
<p>好处：</p>
<ol>
<li>提高灵活性，避免类型错误</li>
<li>节约内存</li>
</ol>
<p><strong>不支持降级</strong></p>
<h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><blockquote>
<p>  缩列表（ziplist）是列表键和哈希键的底层实现之一。</p>
<p>  当一个列表键只包含少量列表项， 并且每个列表项要么就是<strong>小整数值</strong>， 要么就是长度<strong>比较短的字符串</strong>， 那么 Redis 就会使用压缩列表来做列表键的底层实现。</p>
<p>  当一个哈希键只包含少量键值对， 并且每个键值对的键和值要么就是小整数值， 要么就是长度比较短的字符串， 那么 Redis 就会使用压缩列表来做哈希键的底层实现。</p>
</blockquote>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p><img src="http://minsming.com/img/压缩列表组成.png" alt=""></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>长度</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>zlbytes</code></td>
<td><code>uint32_t</code></td>
<td><code>4</code> 字节</td>
<td>记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配， 或者计算 <code>zlend</code>的位置时使用。</td>
</tr>
<tr>
<td><code>zltail</code></td>
<td><code>uint32_t</code></td>
<td><code>4</code> 字节</td>
<td>记录压缩列表表尾节点距离压缩列表的起始地址有多少字节： 通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。</td>
</tr>
<tr>
<td><code>zllen</code></td>
<td><code>uint16_t</code></td>
<td><code>2</code> 字节</td>
<td>记录了压缩列表包含的节点数量： 当这个属性的值小于 <code>UINT16_MAX</code> （<code>65535</code>）时， 这个属性的值就是压缩列表包含节点的数量； 当这个值等于 <code>UINT16_MAX</code> 时， 节点的真实数量需要遍历整个压缩列表才能计算得出。</td>
</tr>
<tr>
<td><code>entryX</code></td>
<td>列表节点</td>
<td>不定</td>
<td>压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</td>
</tr>
<tr>
<td><code>zlend</code></td>
<td><code>uint8_t</code></td>
<td><code>1</code> 字节</td>
<td>特殊值 <code>0xFF</code> （十进制 <code>255</code> ），用于标记压缩列表的末端。</td>
</tr>
</tbody>
</table>
<h3 id="压缩列表节点构成"><a href="#压缩列表节点构成" class="headerlink" title="压缩列表节点构成"></a>压缩列表节点构成</h3><p>每个压缩列表节点可以保存一个<strong>字节数组</strong>或者一个<strong>整数值</strong>， 其中， 字节数组可以是以下三种长度的其中一种：</p>
<ol>
<li>长度小于等于 <code>63</code> （$2^6-1$）字节的字节数组；</li>
<li>长度小于等于 <code>16383</code> （$2^{14}-1$） 字节的字节数组；</li>
<li>长度小于等于 <code>4294967295</code> （$2^{32}-1$）字节的字节数组；</li>
</ol>
<p>而整数值则可以是以下六种长度的其中一种：</p>
<ol>
<li><code>4</code> 位长，介于 <code>0</code> 至 <code>12</code> 之间的无符号整数；</li>
<li><code>1</code> 字节长的有符号整数；</li>
<li><code>3</code> 字节长的有符号整数；</li>
<li><code>int16_t</code> 类型整数；</li>
<li><code>int32_t</code> 类型整数；</li>
<li><code>int64_t</code> 类型整数。</li>
</ol>
<p><img src="http://minsming.com/img/压缩列表节点.png" alt=""></p>
<p><strong>previous_entry_length</strong></p>
<p>节点的 <code>previous_entry_length</code> 属性以字节为单位， 记录了压缩列表中前一个节点的长度。</p>
<p><code>previous_entry_length</code> 属性的长度可以是 <code>1</code> 字节或者 <code>5</code> 字节：</p>
<ul>
<li>如果前一节点的长度小于 <code>254</code> 字节， 那么 <code>previous_entry_length</code> 属性的长度为 <code>1</code> 字节： 前一节点的长度就保存在这一个字节里面。</li>
<li>如果前一节点的长度大于等于 <code>254</code> 字节， 那么 <code>previous_entry_length</code> 属性的长度为 <code>5</code> 字节： 其中属性的第一字节会被设置为 <code>0xFE</code>（十进制值 <code>254</code>）， 而之后的四个字节则用于保存前一节点的长度。</li>
</ul>
<p><strong>因为节点的 <code>previous_entry_length</code> 属性记录了前一个节点的长度， 所以程序可以通过指针运算， 根据当前节点的起始地址来计算出前一个节点的起始地址。</strong></p>
<p><strong>encoding</strong></p>
<ul>
<li>一字节、两字节或者五字节长， 值的最高位为 <code>00</code> 、 <code>01</code> 或者 <code>10</code> 的是字节数组编码： 这种编码表示节点的 <code>content</code> 属性保存着字节数组， 数组的长度由编码除去最高两位之后的其他位记录；</li>
<li>一字节长， 值的最高位以 <code>11</code> 开头的是整数编码： 这种编码表示节点的 <code>content</code> 属性保存着整数值， 整数值的类型和长度由编码除去最高两位之后的其他位记录；</li>
</ul>
<h3 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h3><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><blockquote>
<p>  Redis 使用对象来表示数据库中的键和值， 每次当我们在 Redis 的数据库中新创建一个键值对时， 我们至少会创建两个对象， 一个对象用作键值对的键（<strong>键对象</strong>）， 另一个对象用作键值对的值（<strong>值对象</strong>）。</p>
</blockquote>
<h3 id="类型与编码"><a href="#类型与编码" class="headerlink" title="类型与编码"></a>类型与编码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>
<p><strong>类型</strong></p>
<table>
<thead>
<tr>
<th>类型常量</th>
<th>对象的名称</th>
<th>TYPE命令的输出</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>REDIS_STRING</code></td>
<td>字符串对象</td>
<td>“string”</td>
</tr>
<tr>
<td><code>REDIS_LIST</code></td>
<td>列表对象</td>
<td>“list”</td>
</tr>
<tr>
<td><code>REDIS_HASH</code></td>
<td>哈希对象</td>
<td>“hash”</td>
</tr>
<tr>
<td><code>REDIS_SET</code></td>
<td>集合对象</td>
<td>“set”</td>
</tr>
<tr>
<td><code>REDIS_ZSET</code></td>
<td>有序集合对象</td>
<td>“zset”</td>
</tr>
</tbody>
</table>
<p> <strong>对象的编码</strong></p>
<table>
<thead>
<tr>
<th>编码常量</th>
<th>编码所对应的底层数据结构</th>
<th>OBJECT ENCODING命令输出</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>REDIS_ENCODING_INT</code></td>
<td><code>long</code> 类型的整数</td>
<td>“int”</td>
</tr>
<tr>
<td><code>REDIS_ENCODING_EMBSTR</code></td>
<td><code>embstr</code> 编码的简单动态字符串</td>
<td>“embstr”</td>
</tr>
<tr>
<td><code>REDIS_ENCODING_RAW</code></td>
<td>简单动态字符串</td>
<td>“raw”</td>
</tr>
<tr>
<td><code>REDIS_ENCODING_HT</code></td>
<td>字典</td>
<td>“hashtable”</td>
</tr>
<tr>
<td><code>REDIS_ENCODING_LINKEDLIST</code></td>
<td>双端链表</td>
<td>“linkedlist”</td>
</tr>
<tr>
<td><code>REDIS_ENCODING_ZIPLIST</code></td>
<td>压缩列表</td>
<td>“ziplist”</td>
</tr>
<tr>
<td><code>REDIS_ENCODING_INTSET</code></td>
<td>整数集合</td>
<td>“intset”</td>
</tr>
<tr>
<td><code>REDIS_ENCODING_SKIPLIST</code></td>
<td>跳跃表和字典</td>
<td>“skiplist”</td>
</tr>
</tbody>
</table>
<p><strong>不同类型和编码的对象</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>编码</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>REDIS_STRING</code></td>
<td><code>REDIS_ENCODING_INT</code></td>
<td>使用整数值实现的字符串对象。</td>
</tr>
<tr>
<td><code>REDIS_STRING</code></td>
<td><code>REDIS_ENCODING_EMBSTR</code></td>
<td>使用 <code>embstr</code> 编码的简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td><code>REDIS_STRING</code></td>
<td><code>REDIS_ENCODING_RAW</code></td>
<td>使用简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td><code>REDIS_LIST</code></td>
<td><code>REDIS_ENCODING_ZIPLIST</code></td>
<td>使用压缩列表实现的列表对象。</td>
</tr>
<tr>
<td><code>REDIS_LIST</code></td>
<td><code>REDIS_ENCODING_LINKEDLIST</code></td>
<td>使用双端链表实现的列表对象。</td>
</tr>
<tr>
<td><code>REDIS_HASH</code></td>
<td><code>REDIS_ENCODING_ZIPLIST</code></td>
<td>使用压缩列表实现的哈希对象。</td>
</tr>
<tr>
<td><code>REDIS_HASH</code></td>
<td><code>REDIS_ENCODING_HT</code></td>
<td>使用字典实现的哈希对象。</td>
</tr>
<tr>
<td><code>REDIS_SET</code></td>
<td><code>REDIS_ENCODING_INTSET</code></td>
<td>使用整数集合实现的集合对象。</td>
</tr>
<tr>
<td><code>REDIS_SET</code></td>
<td><code>REDIS_ENCODING_HT</code></td>
<td>使用字典实现的集合对象。</td>
</tr>
<tr>
<td><code>REDIS_ZSET</code></td>
<td><code>REDIS_ENCODING_ZIPLIST</code></td>
<td>使用压缩列表实现的有序集合对象。</td>
</tr>
<tr>
<td><code>REDIS_ZSET</code></td>
<td><code>REDIS_ENCODING_SKIPLIST</code></td>
<td>使用跳跃表和字典实现的有序集合对象。</td>
</tr>
</tbody>
</table>
<h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h3><p>字符串对象的编码可以是 <code>int</code> 、 <code>raw</code> 或者 <code>embstr</code> 。</p>
<ul>
<li><p><strong>int</strong>：一个字符串对象保存的是整数值， 并且这个整数值可以用 <code>long</code> 类型来表示。</p>
</li>
<li><p><strong>raw</strong>：字符串对象保存的是一个字符串值，并且这个字符创值的长度<strong>大于39字节</strong></p>
</li>
<li><p><strong>embstr</strong>：编码是专门用于保存短字符串的一种优化编码方式， 这种编码和 <code>raw</code> 编码一样， 都使用 <code>redisObject</code> 结构和 <code>sdshdr</code> 结构来表示字符串对象， 但 <code>raw</code> 编码会调用两次内存分配函数来分别创建 <code>redisObject</code> 结构和 <code>sdshdr</code> 结构， 而 <code>embstr</code> 编码则通过调用一次内存分配函数来分配一块连续的空间， 空间中依次包含 <code>redisObject</code> 和 <code>sdshdr</code> 两个结构。、</p>
<p>好处：</p>
<ul>
<li>内存分配只要一次（raw需要两次）</li>
<li>释放字符串对象只需要调用一次内存释放函数</li>
<li>因为 <code>embstr</code> 编码的字符串对象的所有数据都保存在一块连续的内存里面， 所以这种编码的字符串对象比起 <code>raw</code> 编码的字符串对象能够更好地利用缓存带来的优势。</li>
</ul>
</li>
</ul>
<p>编码转换：</p>
<ul>
<li>int编码的字符串对象，如果执行命令后使得对象保存的不再是整数值，编码会转为raw</li>
<li>embstr是可读的，所以如果修改embstr，需要先转换为raw再进行修改</li>
</ul>
<h3 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h3><blockquote>
<p>  列表对象的编码可以是<code>ziplist</code>或者<code>linkedlist</code></p>
</blockquote>
<ul>
<li><code>ziplist</code> 编码的列表对象使用压缩列表作为底层实现， 每个压缩列表节点（entry）保存了一个列表元素。</li>
<li><code>linkedlist</code> 编码的列表对象使用双端链表作为底层实现， 每个双端链表节点（node）都保存了一个字符串对象， 而每个字符串对象都保存了一个列表元素。</li>
</ul>
<p><strong>编码转换</strong></p>
<p>当列表对象可以同时满足以下两个条件时， 列表对象使用 <code>ziplist</code> 编码：</p>
<ol>
<li>列表对象保存的所有字符串元素的长度都小于 <code>64</code> 字节；</li>
<li>列表对象保存的元素数量小于 <code>512</code> 个；</li>
</ol>
<p>不能满足这两个条件的列表对象需要使用 <code>linkedlist</code> 编码。</p>
<h3 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h3><blockquote>
<p>  哈希对象的编码可以是 <code>ziplist</code> 或者 <code>hashtable</code> </p>
</blockquote>
<p><code>ziplist</code> 编码的哈希对象使用压缩列表作为底层实现， 每当有新的键值对要加入到哈希对象时， 程序会先将保存了键的压缩列表节点推入到压缩列表表尾， 然后再将保存了值的压缩列表节点推入到压缩列表表尾， 因此：</p>
<ul>
<li>保存了同一键值对的两个节点总是紧挨在一起， 保存键的节点在前， 保存值的节点在后；</li>
<li>先添加到哈希对象中的键值对会被放在压缩列表的表头方向， 而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。</li>
</ul>
<p><code>hashtable</code> 编码的哈希对象使用字典作为底层实现， 哈希对象中的每个键值对都使用一个字典键值对来保存：</p>
<ul>
<li>字典的每个键都是一个字符串对象， 对象中保存了键值对的键；</li>
<li>字典的每个值都是一个字符串对象， 对象中保存了键值对的值。</li>
</ul>
<p><strong>编码转换</strong></p>
<p>当哈希对象可以同时满足以下两个条件时， 哈希对象使用 <code>ziplist</code> 编码：</p>
<ol>
<li>哈希对象保存的所有键值对的键和值的字符串长度都小于 <code>64</code> 字节；</li>
<li>哈希对象保存的键值对数量小于 <code>512</code> 个；</li>
</ol>
<p>不能满足这两个条件的哈希对象需要使用 <code>hashtable</code> 编码。</p>
<h3 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h3><blockquote>
<p>  集合对象的编码可以是 <code>intset</code> 或者 <code>hashtable</code> </p>
</blockquote>
<ul>
<li><code>intset</code> 编码的集合对象使用整数集合作为底层实现， 集合对象包含的所有元素都被保存在整数集合里面。</li>
<li><code>hashtable</code> 编码的集合对象使用字典作为底层实现， 字典的每个键都是一个字符串对象， 每个字符串对象包含了一个集合元素， 而字典的值则全部被设置为 <code>NULL</code> 。</li>
</ul>
<p><strong>编码转换</strong></p>
<p>当集合对象可以同时满足以下两个条件时， 对象使用 <code>intset</code> 编码：</p>
<ol>
<li>集合对象保存的所有元素都是整数值；</li>
<li>集合对象保存的元素数量不超过 <code>512</code> 个；</li>
</ol>
<p>不能满足这两个条件的集合对象需要使用 <code>hashtable</code> 编码。</p>
<h3 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h3><blockquote>
<p>  有序集合的编码可以是 <code>ziplist</code> 或者 <code>skiplist</code></p>
</blockquote>
<ul>
<li><code>ziplist</code> 编码的有序集合对象使用压缩列表作为底层实现， 每个集合元素使用两个紧挨在一起的压缩列表节点来保存， 第一个节点保存元素的成员（member）， 而第二个元素则保存元素的分值（score）。</li>
<li><code>skiplist</code> 编码的有序集合对象使用 <code>zset</code> 结构作为底层实现， 一个 <code>zset</code> 结构同时包含一个字典和一个跳跃表：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    zskiplist *zsl;</span><br><span class="line"></span><br><span class="line">    dict *dict;</span><br><span class="line">&#125; zset;</span><br><span class="line"><span class="comment">// 字典和跳跃表会共享元素的成员和分值， 所以并不会造成任何数据重复， 也不会因此而浪费任何内存。</span></span><br></pre></td></tr></table></figure>
<p><strong>编码转换</strong></p>
<p>当有序集合对象可以同时满足以下两个条件时， 对象使用 <code>ziplist</code> 编码：</p>
<ol>
<li>有序集合保存的元素数量小于 <code>128</code> 个；</li>
<li>有序集合保存的所有元素成员的长度都小于 <code>64</code> 字节；</li>
</ol>
<p>不能满足以上两个条件的有序集合对象将使用 <code>skiplist</code> 编码。</p>
<h3 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h3><p>类型特定命令所进行的类型检查是通过 <code>redisObject</code> 结构的 <code>type</code> 属性来实现的：</p>
<ul>
<li>在执行一个类型特定命令之前， 服务器会先检查输入数据库键的值对象是否为执行命令所需的类型， 如果是的话， 服务器就对键执行指定的命令；</li>
<li>否则， 服务器将拒绝执行命令， 并向客户端返回一个类型错误。</li>
</ul>
<h3 id="多态命令的实现"><a href="#多态命令的实现" class="headerlink" title="多态命令的实现"></a>多态命令的实现</h3><p>Redis 除了会根据值对象的类型来判断键是否能够执行指定命令之外， 还会根据<strong>值对象的编码方式</strong>， 选择正确的命令实现代码来执行命令。</p>
<h3 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h3><p>使用了引用计数法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>
<p>当refcount为0的时候将会被释放，可以通过<code>OBJECT REFCOUNT</code>查看引用值</p>
<h3 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h3><p> Redis 会在初始化服务器时， 创建一万个字符串对象， 这些对象包含了从 <strong>0 到 9999</strong>的所有整数值， 当服务器需要用到值为 <code>0</code>到 <code>9999</code> 的字符串对象时， 服务器就会使用这些<strong>共享对象</strong>， 而不是新创建对象。</p>
<p>为什么 Redis 不共享包含字符串的对象？</p>
<p>当服务器考虑将一个共享对象设置为键的值对象时， 程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同， 只有在共享对象和目标对象完全相同的情况下， 程序才会将共享对象用作键的值对象， 而一个共享对象保存的值越复杂， 验证共享对象和目标对象是否相同所需的复杂度就会越高， 消耗的 CPU 时间也会越多：</p>
<ul>
<li>如果共享对象是保存整数值的字符串对象， 那么验证操作的复杂度为 O(1) ；</li>
<li>如果共享对象是保存字符串值的字符串对象， 那么验证操作的复杂度为 O(N) ；</li>
<li>如果共享对象是包含了多个值（或者对象的）对象， 比如列表对象或者哈希对象， 那么验证操作的复杂度将会是 O(N^2) 。</li>
</ul>
<p>因此， 尽管共享更复杂的对象可以节约更多的内存， 但受到 CPU 时间的限制， Redis 只对包含整数值的字符串对象进行共享。</p>
<h3 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h3><p>通过以下属性标识，记录了对象最后一次被命令程序访问的时间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:<span class="number">22</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>
<p>空转时长较高的那部分键会优先被服务器释放。</p>
<hr>
<p>参考：Redis设计与实现</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/笔记/">笔记</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/redis/">redis</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://minsming.com/2018/12/11/Redis/" data-title="Redis底层数据结构 | 小铭" data-tsina="" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2018/12/11/Redis——数据库/" title="Redis——数据库">
  <strong>上一篇：</strong><br/>
  <span>
  Redis——数据库</span>
</a>
</div>


<div class="next">
<a href="/2018/10/02/Ubuntu18.04搭建Hadoop3.0.3/"  title="Ubuntu18.04搭建Hadoop3.0.3">
 <strong>下一篇：</strong><br/> 
 <span>Ubuntu18.04搭建Hadoop3.0.3
</span>
</a>
</div>

</nav>

	



</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">我的Github</p>
<div class="github-card" data-github="zhengjunming" data-theme="medium"></div>
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>



  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/分布式/" title="分布式">分布式<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/数据结构/" title="数据结构">数据结构<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/笔记/" title="笔记">笔记<sup>23</sup></a></li>
		  
		
		  
			<li><a href="/categories/设计模式/" title="设计模式">设计模式<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/问题/" title="问题">问题<sup>3</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/多线程/" title="多线程">多线程<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/Spring/" title="Spring">Spring<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/MySQL/" title="MySQL">MySQL<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/redis/" title="redis">redis<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/JVM/" title="JVM">JVM<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/404/" title="404">404<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/NIO/" title="NIO">NIO<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/GC/" title="GC">GC<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/线程池/" title="线程池">线程池<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Maven/" title="Maven">Maven<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/B树/" title="B树">B树<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Socket/" title="Socket">Socket<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Springboot/" title="Springboot">Springboot<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/war包/" title="war包">war包<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/HTTP/" title="HTTP">HTTP<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/线程/" title="线程">线程<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/单例模式/" title="单例模式">单例模式<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/平衡二叉树/" title="平衡二叉树">平衡二叉树<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/hadoop/" title="hadoop">hadoop<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Mybatis/" title="Mybatis">Mybatis<sup>1</sup></a></li>
			
		
		</ul>
</div>


  
  <div class="tagcloudlist">
    <p class="asidetitle">标签云</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/404/" style="font-size: 12.5px;">404</a> <a href="/tags/B树/" style="font-size: 10px;">B树</a> <a href="/tags/GC/" style="font-size: 10px;">GC</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/JVM/" style="font-size: 12.5px;">JVM</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Mybatis/" style="font-size: 10px;">Mybatis</a> <a href="/tags/NIO/" style="font-size: 10px;">NIO</a> <a href="/tags/Socket/" style="font-size: 10px;">Socket</a> <a href="/tags/Spring/" style="font-size: 17.5px;">Spring</a> <a href="/tags/Springboot/" style="font-size: 10px;">Springboot</a> <a href="/tags/hadoop/" style="font-size: 10px;">hadoop</a> <a href="/tags/redis/" style="font-size: 12.5px;">redis</a> <a href="/tags/war包/" style="font-size: 10px;">war包</a> <a href="/tags/单例模式/" style="font-size: 10px;">单例模式</a> <a href="/tags/多线程/" style="font-size: 20px;">多线程</a> <a href="/tags/平衡二叉树/" style="font-size: 10px;">平衡二叉树</a> <a href="/tags/线程/" style="font-size: 10px;">线程</a> <a href="/tags/线程池/" style="font-size: 10px;">线程池</a>
    </div>
  </div>


  

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> 认真做好每一件事 <br/>
			记录生活，记录技术</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		<a href="https://github.com/zhengjunming" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		<a href="mailto:gdutxming@163.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2019 
		
		<a href="/about" target="_blank" title="ming">ming</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>











<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?5c5e9be8c140785b7522d4fe313c87d3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
